@namespace Ozds.Client.Components.Streaming

@typeparam L where L : notnull
@using Ozds.Business.Models.Abstractions
@using Ozds.Business.Mutations.Agnostic
@using Microsoft.AspNetCore.Components.Forms
@using Microsoft.Extensions.DependencyInjection
@using Ozds.Client.Components.Fields
@using Ozds.Client.State
@using MudBlazor
@inherits Ozds.Client.Base.OzdsOwningComponentBase

@inject IDialogService DialogService

<Loading
  T="L"
  Value="@Value"
  Progress="@Progress"
  Error="@Error"
  Id="@Id"
  Load="@Load"
  LoadAsync="@LoadAsync"
  New="@New"
  NewAsync="@NewAsync"
  ActivateAsync>
  <Found Context="model">
    @if (Label is not null)
    {
      @Label(new MutatingState<L>(model, false))
      <MudDivider Class="mb-4" />
    }
    else if (model is IIdentifiable identifiable)
    {
      <MudText Typo="Typo.h5" Class="mb-2">
        @if (_mutating)
        {
          @T["Edit"]
          <span>&nbsp;</span>
        }
        @(identifiable.Title)
      </MudText>
      <MudDivider Class="mb-4" />
      <DetailsField Title="@T["Id"]">
        @identifiable.Id
      </DetailsField>
    }
    else
    {
      <MudText Typo="Typo.h5" Class="mb-2">
        @if (_mutating)
        {
          @T["Edit"]
          <span>&nbsp;</span>
        }
        @(typeof(L).Name)
      </MudText>
      <MudDivider Class="mb-4" />
    }

    @if (model is IReadonly)
    {
      @Details(new MutatingState<L>(model, false))
    }
    else
    {
      <EditForm
        Model="@model"
        OnValidSubmit="@(() => OnUpdate(model))">
        <DataAnnotationsValidator/>
        @if (_mutating)
        {
          @Edit(new MutatingState<L>(model, false))
          <div Class="d-flex flex-column mt-4">
            <div Class="d-flex flex-row">
              <MudButton
                Variant="Variant.Filled"
                Color="MudBlazor.Color.Success"
                ButtonType="ButtonType.Submit">
                @T["Update"]
              </MudButton>
              <MudButton
                Variant="Variant.Filled"
                Color="MudBlazor.Color.Secondary"
                OnClick="@(() => _mutating = !_mutating)"
                Class="ml-4">
                @T["Preview"]
              </MudButton>
            </div>
            <MudButton
              Variant="Variant.Filled"
              Color="MudBlazor.Color.Error"
              OnClick="@(() => OnDelete(model))"
              Class="mt-8 align-self-start">
              @T["Delete"]
            </MudButton>
          </div>
        }
        else
        {
          @Details(new MutatingState<L>(model, false))
          @if (model is not IReadonly)
          {
            <div Class="d-flex flex-row mt-4">
              <MudButton
                OnClick="@(() => _mutating = !_mutating)"
                Variant="Variant.Filled"
                Color="MudBlazor.Color.Warning">
                @T["Edit"]
              </MudButton>
            </div>
          }
        }
      </EditForm>
    }
  </Found>
  <Created Context="model">
    @if (Label is not null)
    {
      @Label(new MutatingState<L>(model, true))
    }
    else
    {
      <MudText Typo="Typo.h5" Class="mb-2">
        @T["Create"] @(typeof(L).Name)
      </MudText>
    }
    <MudDivider Class="mb-4" />
    <EditForm
      Model="@model"
      OnValidSubmit="@(() => OnCreate(model))">
      <DataAnnotationsValidator/>
      @if (!_mutating)
      {
        @Edit(new MutatingState<L>(model, true))
        <div Class="d-flex flex-row mt-4">
          <MudButton
            ButtonType="ButtonType.Submit"
            Variant="Variant.Filled"
            Color="MudBlazor.Color.Success">
            @T["Create"]
          </MudButton>
          <MudButton
            OnClick="@(() => _mutating = !_mutating)"
            Variant="Variant.Filled"
            Color="MudBlazor.Color.Secondary"
            Class="ml-4">
            @T["Preview"]
          </MudButton>
        </div>
      }
      else
      {
        @Details(new MutatingState<L>(model, true))
        <div Class="d-flex flex-row mt-4">
          <MudButton
            OnClick="@(() => _mutating = !_mutating)"
            Variant="Variant.Filled"
            Color="MudBlazor.Color.Warning">
            @T["Edit"]
          </MudButton>
        </div>
      }
    </EditForm>
  </Created>
</Loading>

@code {

  [Parameter]
  public L? Value { get; set; }

  [Parameter]
  public string? Id { get; set; } = default!;

  [Parameter]
  public RenderFragment? Progress { get; set; }

  [Parameter]
  public Func<L?>? Load { get; set; }

  [Parameter]
  public Func<Task<L?>>? LoadAsync { get; set; }

  [Parameter]
  public Func<L>? New { get; set; }

  [Parameter]
  public Func<Task<L>>? NewAsync { get; set; }

  [Parameter]
  public RenderFragment<string>? Error { get; set; }

  [Parameter]
  public Action<L>? Create { get; set; }

  [Parameter]
  public Func<L, Task>? CreateAsync { get; set; }

  [Parameter]
  public Action<L>? Update { get; set; }

  [Parameter]
  public Func<L, Task>? UpdateAsync { get; set; }

  [Parameter]
  public Action<L>? Delete { get; set; }

  [Parameter]
  public Func<L, Task>? DeleteAsync { get; set; }

  [Parameter]
  public RenderFragment<MutatingState<L>>? Label { get; set; } = default!;

  [Parameter]
  public RenderFragment<MutatingState<L>> Details { get; set; } = default!;

  [Parameter]
  public RenderFragment<MutatingState<L>> Edit { get; set; } = default!;

  private bool _mutating;

  private async Task OnCreate(L model)
  {
    try
    {
      if (Create is not null)
      {
        Create(model);
      }
      else if (CreateAsync is not null)
      {
        await CreateAsync(model);
      }
      else if (model?.GetType().IsAssignableTo(typeof(IAuditable)) ?? false)
      {
        var mutations = ScopedServices.GetRequiredService<AuditableMutations>();
        await mutations.Create((model as IAuditable)!, CancellationToken.None);
      }
      else
      {
        throw new InvalidOperationException(
          $"No create strategy found for {typeof(L).Name}");
      }
    }
    catch (Exception ex)
    {
      DialogService.Show<MutatingResult>(
        T["Failure"],
        new DialogParameters { { nameof(MutatingResult.Body), $"{T["Failed creating"]} {T[typeof(L).Name]} - {ex.Message}" } },
        new DialogOptions { CloseOnEscapeKey = true });
      return;
    }

    DialogService.Show<MutatingResult>(
      T["Success"],
      new DialogParameters { { nameof(MutatingResult.Body), $"{T["Successfully created"]} {T[typeof(L).Name]}" } },
      new DialogOptions { CloseOnEscapeKey = true });
  }

  private async Task OnUpdate(L model)
  {
    try
    {
      if (Update is not null)
      {
        Update(model);
      }
      else if (UpdateAsync is not null)
      {
        await UpdateAsync(model);
      }
      else if (model?.GetType().IsAssignableTo(typeof(IAuditable)) ?? false)
      {
        var mutations = ScopedServices.GetRequiredService<AuditableMutations>();
        await mutations.Update((model as IAuditable)!, CancellationToken.None);
      }
      else
      {
        throw new InvalidOperationException(
          $"No update strategy found for {typeof(L).Name}");
      }
    }
    catch (Exception ex)
    {
      DialogService.Show<MutatingResult>(
        T["Failure"],
        new DialogParameters { { nameof(MutatingResult.Body), $"{T["Failed updating"]} {T[typeof(L).Name]} - {ex.Message}" } },
        new DialogOptions { CloseOnEscapeKey = true });
      return;
    }

    DialogService.Show<MutatingResult>(
      T["Success"],
      new DialogParameters { { nameof(MutatingResult.Body), $"{T["Successfully updated"]} {T[typeof(L).Name]}" } },
      new DialogOptions { CloseOnEscapeKey = true });
  }

  private async Task OnDelete(L model)
  {
    try
    {
      if (Delete is not null)
      {
        Delete(model);
      }
      else if (DeleteAsync is not null)
      {
        await DeleteAsync(model);
      }
      else if (model?.GetType().IsAssignableTo(typeof(IAuditable)) ?? false)
      {
        var mutations = ScopedServices.GetRequiredService<AuditableMutations>();
        await mutations.Delete((model as IAuditable)!, CancellationToken.None);
      }
      else
      {
        throw new InvalidOperationException(
          $"No delete strategy found for {typeof(L).Name}");
      }
    }
    catch (Exception ex)
    {
      DialogService.Show<MutatingResult>(
        T["Failure"],
        new DialogParameters { { nameof(MutatingResult.Body), $"{T["Failed deleting"]} {T[typeof(L).Name]} - {ex.Message}" } },
        new DialogOptions { CloseOnEscapeKey = true });
      return;
    }

    DialogService.Show<MutatingResult>(
      T["Success"],
      new DialogParameters { { nameof(MutatingResult.Body), $"{T["Successfully deleted"]} {T[typeof(L).Name]}" } },
      new DialogOptions { CloseOnEscapeKey = true });
  }

}
